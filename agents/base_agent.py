import os
from typing import List, Callable, Dict, Any, Optional
from google import genai
from google.genai import types
import yaml
import inspect
from utils.memory_store import MemoryStore

class BaseAgent:
    def __init__(self, name: str, config_path: str = "config.yaml"):
        self.name = name
        self.config_path = config_path
        self.config = self._load_config()
        self.model_config = self.config.get('model_config', {})
        
        # Initialize Memory Store
        self.memory_store = MemoryStore()
        
        # Initialize Gemini Client
        api_key = os.environ.get("GOOGLE_API_KEY")
        if not api_key:
            print(f"[{self.name}] WARNING: GOOGLE_API_KEY not found. Agent will fail if it tries to call Gemini.")
            self.client = None
        else:
            self.client = genai.Client(api_key=api_key)
            
        self.model_name = self.model_config.get('model_name', 'gemini-2.5-flash-lite')
        self.tools: Dict[str, Callable] = {}
        self.history: List[types.Content] = []
        self.system_instruction: str = ""
        
        # Register Memory Tools
        self.register_tool(self.save_insight)
        self.register_tool(self.get_insight)

    def _load_config(self) -> Dict:
        try:
            with open(self.config_path, 'r') as f:
                return yaml.safe_load(f)
        except Exception as e:
            print(f"[{self.name}] Error loading config: {e}")
            return {}

    def register_tool(self, func: Callable):
        """Registers a Python function as a tool for the agent."""
        self.tools[func.__name__] = func

    def set_system_instruction(self, instruction: str):
        self.system_instruction = instruction

    # Memory Tools
    def save_insight(self, key: str, value: str) -> str:
        """Saves a key-value fact to long-term memory."""
        return self.memory_store.save_insight(key, value)

    def get_insight(self, key: str) -> str:
        """Retrieves a fact from long-term memory."""
        return self.memory_store.get_insight(key)

    def run(self, prompt: str) -> str:
        """
        Sends a prompt to the model, handles tool calls, and returns the text response.
        """
        if not self.client:
            return "Error: GOOGLE_API_KEY not set."

        print(f"[{self.name}] Thinking...")
        
        # Prepare tools for the API
        tool_list = [func for func in self.tools.values()] if self.tools else None
        
        # Create chat session if not exists (or continue history)
        # Note: In a real ADK, we might manage session state more explicitly.
        # Here we use a simple generate_content with history management manually or via ChatSession.
        
        # We will use a fresh chat session for each 'run' in this simple PoC, 
        # but pre-load it with history if we wanted persistent memory.
        # For this PoC, we'll treat 'run' as a single turn or a continuation.
        
        chat = self.client.chats.create(
            model=self.model_name,
            config=types.GenerateContentConfig(
                temperature=self.model_config.get('temperature', 0.2),
                max_output_tokens=self.model_config.get('max_output_tokens', 2048),
                tools=tool_list,
                system_instruction=self.system_instruction
            ),
            history=self.history
        )

        try:
            response = chat.send_message(prompt)
            
            # The response might be a tool call.
            # If using automatic function calling (not yet fully standard in all SDK versions without setup),
            # we might need to loop. 
            # Check for valid candidates
            if not response.candidates:
                print(f"[{self.name}] Error: No candidates returned. Likely safety filter or empty response.")
                return "Error: No response generated by the model."
            
            candidate = response.candidates[0]
            
            # Check for valid content
            if not candidate.content or not candidate.content.parts:
                 print(f"[{self.name}] Warning: Candidate content is empty. Finish reason: {candidate.finish_reason}")
                 return "Error: Model returned empty content."

            # Check for function calls
            for part in candidate.content.parts:
                if part.function_call:
                    func_name = part.function_call.name
                    args = part.function_call.args
                    
                    print(f"[{self.name}] Tool Call: {func_name}")
                    
                    if func_name in self.tools:
                        try:
                            # Convert args to native python types recursively
                            # The SDK returns MapComposite and RepeatedComposite which json.dumps hates.
                            tool_args = self._to_python_types(args)
                            result = self.tools[func_name](**tool_args)
                            return str(result)
                        except Exception as e:
                            print(f"[{self.name}] Tool Execution Error: {e}")
                            return f"Error executing tool {func_name}: {e}"
                    else:
                        return f"Error: Tool {func_name} not found."

            # Simple return for text
            text_response = response.text
            if text_response is None:
                 text_response = "Error: Model returned None text."
            
            # Update history
            # Update history manually since chat.history might not be accessible or standard
            # We know what we sent and what we got.
            self.history.append(types.Content(role="user", parts=[types.Part(text=prompt)]))
            self.history.append(types.Content(role="model", parts=[types.Part(text=text_response)]))
            
            # Log to Memory Store
            self.memory_store.log_interaction(prompt, text_response, self.name)
            
            print(f"[{self.name}] Response: {text_response[:100]}...")
            return text_response

        except Exception as e:
            print(f"[{self.name}] Error during generation: {e}")
            if "API key not valid" in str(e) or "API_KEY_INVALID" in str(e):
                print(f"[{self.name}] FALLBACK: Simulating response for PoC.")
                return self._mock_response(prompt)
            return f"Error: {e}"

    def _to_python_types(self, obj):
        """Recursively converts Protobuf Map/List to native Python dict/list."""
        if hasattr(obj, 'items'): # MapComposite
            return {k: self._to_python_types(v) for k, v in obj.items()}
        elif hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes)): # RepeatedComposite
            return [self._to_python_types(v) for v in obj]
        else:
            return obj

    def _mock_response(self, prompt: str) -> str:
        """Generates a dummy response based on the agent name for testing."""
        if self.name == "PolicyAgent":
            return "The strategic SKUs are ['SKU_001', 'SKU_005'] and the capacity limit is 10000."
        elif self.name == "DataAgent":
            return "I have loaded the data, detected 0 anomalies, and cleaned it. Summary: Mean sales is 500."
        elif self.name == "SegmentationAgent":
            # We need to trigger the tool call in a real scenario, but here we just return text
            # In a real mock, we'd manually call the tool.
            return "I have calculated metrics and assigned segments. SKU_001 is stable_seasonal."
        elif self.name == "BaselineAgent":
            return "Forecasts generated for all SKUs using ETS and Croston models."
        elif self.name == "ScenarioAgent":
            return "Scenarios created. Uplifts applied to SKU_001 and SKU_005."
        elif self.name == "NegotiationAgent":
            return "Checked capacity. No violations found in any week."
        elif self.name == "MonitorAgent":
            return "The plan looks good. Total volume is within limits. No cuts were needed."
        return "Mock response."

    def reset_memory(self):
        self.history = []
